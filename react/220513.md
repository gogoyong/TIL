# Ch. 03. React 공식문서로 디테일 잡기  
## 01-04. Hook

## Side Effect

- Side Effect 는 리액트 컴포넌트가 화면에 1차로 렌더링 된 이후에 비동기로 처리되어야 하는 부수적 효과들을 뜻한다.
- 예를 들어 데이터를 가져오려고 외부 API를 호출 할 때 일단 화면에 렌더링 할수 있는 것은 1차로 먼저 렌더링 하고 실제 데이터는 비동기로 가져오는 것이 권장된다. 그 이유는 연동된 API가 응답이 없거나 늦어질 상황이 발생할 수 있기 때문이다. 이때 Hook이 Side Effect 를 수행하는 역할을 한다.

---

## Hook 은 무엇인가?

- hook은 리액트 16.8 버전부터 새로 추가된 요소이다. 함수형 컴포넌트가 클래스형 컴포넌트의 기능을 사용할수 있도록 해주는 몇가지 기술을 Hook 이라고 한다.

---

## Hook의 종류

### State Hook

- 상태관리를 할수 있는 `useState`
- 함수형 컴포넌트 에서는 클래스형 컴포넌트와 같이 state를 사용할 수 없기 때문에, Hook을 사용해서 state 와 같은 기능을 할 수 있다.

```javascript
const [num, setNum] = useState(0); // 구조분해할당, num 이라는 변수와 num을 변경할 수 있는 setNum 이라는 변경함수.
setNum(num + 1);
console.log(num); // 1
```

---

### Effect Hook

- Effect Hook : 렌더링 직후 작업을 설정하는 `useEffect`
- 클래스형 컴포넌트와 다르게 Effect Hook 은 side Effect를 수행할때 , `componentDidMount(){}` 와 `componentWillUnmount(){}` 처럼 나눌 필요 없이 `return` 명령어를 사용해 한번에 처리할 수 있다.

#### 클래스형 컴포넌트 lifeCycle Hook.

```js
class ClassC extends React.Component {
  componentDidMount() {
    //ClassC 컴포넌트가 Mount 되고나서 실행할 코드 (첫 등장 후 실행할 코드)
  }
  componentWillUnmount() {
    //ClassC 컴포넌트가 Unmount 되기전에 실행할 코드(다른 페이지로 넘어간다든지 등의 사유로 컴포넌트가 사라지기 전 실행할 코드 )
  }
}
```

#### 함수형 컴포넌트 Effect Hook.

```js
function FuncC() {
  useEffect(() => {
    /* FuncC 컴포넌트가 mount 되기 전에 실행할 코드 */
    return function toDO() {
      /* FuncC 컴포넌트가 Unmount 되기전에 실행할 코드 */
    };
  });
}
```

#### `useEffect` 여러개 사용하기.

- `useEffect` 는 한번에 여러개도 사용 가능하며 위치에 따라 순차적으로 실행된다.

```js
import React, { useState, useEffect } from "react";

function Func() {
  useEffect(() => {
    //첫번째로 실행할 코드
  });
  useEffect(() => {
    //그 다음으로 실행할 코드
  });
}
```

---

## Hook 사용 규칙

1.  최상위 에서만 Hook을 호출해야 한다. 반복문,조건문,중첩된 함수 내에서 Hook을 실행할 수 없다.
2.  함수형 컴포넌트 내에서만 Hook을 호출해야 한다. 일반 JS 함수 에서는 Hook을 호출해서는 안된다. (custom Hook 내 에서는 호출 가능.)

---

## 05-06. Composition 
component 안에서 component를 모아서 출력하는 것  

[composition(합성) vs inheritance(상속)](https://ko.reactjs.org/docs/composition-vs-inheritance.html)

- 컴포넌트에서 다른 컴포넌트를 담기  

어떤 컴포넌트들은 어떤 자식 엘리먼트가 들어올 지 미리 예상할 수 없는 경우가 있습니다. 범용적인 ‘박스’ 역할을 하는 Sidebar 혹은 Dialog와 같은 컴포넌트에서 특히 자주 볼 수 있습니다.

이러한 컴포넌트에서는 특수한 children prop을 사용하여 자식 엘리먼트를 출력에 그대로 전달하는 것이 좋습니다.
```js
function FancyBorder(props) {
  return (
    <div className={'FancyBorder FancyBorder-' + props.color}>
      {props.children}
    </div>
  );
}
```
이러한 방식으로 다른 컴포넌트에서 JSX를 중첩하여 임의의 자식을 전달할 수 있습니다.
```js
function WelcomeDialog() {
  return (
    <FancyBorder color="blue">
      <h1 className="Dialog-title">
        Welcome
      </h1>
      <p className="Dialog-message">
        Thank you for visiting our spacecraft!
      </p>
    </FancyBorder>
  );
}
```

- 특수화  
때로는 어떤 컴포넌트의 “특수한 경우”인 컴포넌트를 고려해야 하는 경우가 있습니다. 예를 들어, WelcomeDialog는 Dialog의 특수한 경우라고 할 수 있습니다.

React에서는 이 역시 합성을 통해 해결할 수 있습니다. 더 “구체적인” 컴포넌트가 “일반적인” 컴포넌트를 렌더링하고 props를 통해 내용을 구성합니다.

- 컴포넌트에 다른 컴포넌트를 담기
 담는방법 (children / custom)

- 특수화  

- 상속은?
Facebook에서는 수천 개의 React 컴포넌트를 사용하지만, 컴포넌트를 상속 계층 구조로 작성을 권장할만한 사례를 아직 찾지 못했습니다.

props와 합성은 명시적이고 안전한 방법으로 컴포넌트의 모양과 동작을 커스터마이징하는데 필요한 모든 유연성을 제공합니다. 컴포넌트가 원시 타입의 값, React 엘리먼트 혹은 함수 등 어떠한 props도 받을 수 있다는 것을 기억하세요.

UI가 아닌 기능을 여러 컴포넌트에서 재사용하기를 원한다면, 별도의 JavaScript 모듈로 분리하는 것이 좋습니다. 컴포넌트에서 해당 함수, 객체, 클래스 등을 import 하여 사용할 수 있습니다. 상속받을 필요 없이 말이죠.

---
typeof > type check  
확장성 > 다양한 상황을 품을 수 있도록  

---
## 07. HOC  
[Higher Order Component](https://ko.reactjs.org/docs/higher-order-components.html)  

`고차 컴포넌트`(HOC, Higher Order Component)는 컴포넌트 로직을 재사용하기 위한 React의 고급 기술입니다. 고차 컴포넌트(HOC)는 React API의 일부가 아니며, `React의 구성적 특성에서 나오는 패턴`입니다.

`고차 컴포넌트는 컴포넌트를 가져와 새 컴포넌트를 반환하는 함수`

HOC란  
인자로 컴포넌트를 받고 아웃풋으로 새로운 컴포넌트를 출력하는 컴포넌트

```js
const EnhancedComponent = higherOrderComponent(WrappedComponent);
```

재사용성, 효율을 높여준다

`원본 컴포넌트를 변경하지 마세요.` 조합(Composition)하세요.
고차 컴포넌트 내부에서 컴포넌트의 프로토타입을 수정(또는 변경)하지 않도록 합니다

컨벤션: 간단한 디버깅을 위한 디스플레이 네임 작성 방법
다른 구성 요소와 마찬가지로 HOC로 만든 컨테이너 구성 요소도 React Developer Tools에 표시됩니다. 디버깅을 쉽게 하려면 HOC의 결과임을 알리는 디스플레이 네임을 작성합니다.

가장 일반적인 방법은 `HOC의 이름으로 내부 컴포넌트명을 감싸는 것`입니다. 따라서 HOC의 이름이 withSubscription이고, HOC 내부의 컴포넌트의 이름이 CommentList 인 경우, 디스플레이 네임은 WithSubscription(CommentList)을 사용합니다.

`render 메서드 안에서 고차 컴포넌트를 사용하지 마세요`  

ref는 전달되지 않는다
: 문제의 해결 방법은 React.forwardRef API를 사용하는 것입니다.  

HOC는 함수를 받아서 함수를 리턴한다.  

---

## Memoization 메모이제이션

- 메모이제이션은 컴퓨터 프로그램이 **동일한 계산**을 **반복**해야 할 때, 이전에 계산한 값을 **메모리에 저장**함으로써 동인한 계산의 반복 수행의 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다.
- https://ko.wikipedia.org/wiki/%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98

```js
// App.js
import './App.css';
import Memo from './components/3-8.Memoization/Memo';

function App() {
  return (
    <div className='App'>
      <Memo />
    </div>
  );
}

export default App;
```

```jsx
// Memo.jsx
import React, { useState } from 'react';
import Comments from './Comments';

const commentList = [
  { title: 'comment1', content: 'message1', likes: 1 },
  { title: 'comment2', content: 'message2', likes: 1 },
  { title: 'comment3', content: 'message3', likes: 1 },
];

export default function Memo() {
  const [comments, setComments] = useState(commentList);
  return <Comments commentList={comments} />;
}
```

```jsx
// Comments.jsx
import React from 'react';
import CommentsItem from './CommentItem';

export default function Comments({ commentList }) {
  return (
    <div>
      {commentList.map((comment) => (
        <CommentsItem
          key={comment.title}
          title={comment.title}
          content={comment.content}
          likes={comment.likes}
        />
      ))}
    </div>
  );
}
```

```jsx
// CommentItem.jsx
import React from 'react';
import './CommentItem.css';

export default function CommentItem({ title, content, likes }) {
  return (
    <div className='CommentItem'>
      <span>{title}</span>
      <br />
      <span>{content}</span>
      <br />
      <span>{likes}</span>
    </div>
  );
}
```

```css
/* CommentItem.css */
.CommentItem {
  border-bottom: 1px solid gray;
  padding: 10px;
  cursor: pointer;
  background-color: pink;
}
```

#### React.memo

- https://ko.reactjs.org/docs/react-api.html#reactmemo

- 동일한 props 로 렌더링을 한다면, React.memo를 사용하여 성능향상을 누릴 수 있다
- memo를 사용하면 React는 컴포넌트를 렌더링하지 않고 마지막으로 렌더링된 결과를 재사용 한다.

```jsx
// CommentItem.jsx
import React, { memo } from 'react';
import './CommentItem.css';
export default memo(CommentItem);
```

```jsx
// App.jsx 설정된 시간에 맞춰서 계속 comment 생성
export default function Memo() {
  const [comments, setComments] = useState(commentList);

  // 시간에 맞춰서 계속 생성
  useEffect(() => {
    const interval = setInterval(() => {
      setComments((prevComments) => [
        ...prevComments,
        {
          title: `comment${prevComments.length + 1}`,
          content: `message${prevComments.length + 1}`,
          likes: 1,
        },
      ]);
    }, 1000);

    return () => {
      clearInterval(interval);
    };
  }, []);

  return <Comments commentList={comments} />;
}
```

#### Profiler

- https://ko.reactjs.org/docs/profiler.html
  > Profiler는 React 애플리케이션이 렌더링하는 빈도와 렌더링 “비용”을 측정합니다.
  > Profiler의 목적은 메모이제이션 같은 성능 최적화 방법을 활용할 수 있는 애플리케이션의 느린 부분들을 식별해내는 것입니다.

```jsx
// Memo.jsx
import React, { useEffect, useState } from 'react';
import Comments from './Comments';

const commentList = [
  { title: 'comment1', content: 'message1', likes: 1 },
  { title: 'comment2', content: 'message2', likes: 1 },
  { title: 'comment3', content: 'message3', likes: 1 },
];

export default function Memo() {
  const [comments, setComments] = useState(commentList);

  // 시간에 맞춰서 계속 생성
  useEffect(() => {
    const interval = setInterval(() => {
      setComments((prevComments) => [
        ...prevComments,
        {
          title: `comment${prevComments.length + 1}`,
          content: `message${prevComments.length + 1}`,
          likes: 1,
        },
      ]);
    }, 1000);

    return () => {
      clearInterval(interval);
    };
  }, []);

  return <Comments commentList={comments} />;
}
```

```jsx
// Comments.jsx
import React, { useCallback } from 'react';
import CommentsItem from './CommentItem';

export default function Comments({ commentList }) {
  const handleClick = useCallback(() => {
    console.log('눌림');
  }, []);
  return (
    <div>
      {commentList.map((comment) => (
        <CommentsItem
          key={comment.title}
          title={comment.title}
          content={comment.content}
          likes={comment.likes}
          onClick={handleClick}
        />
      ))}
    </div>
  );
}
```

```jsx
// CommentItem.jsx
import React, { Profiler, memo, useState, useMemo } from 'react';
import './CommentItem.css';

function CommentItem({ title, content, likes, onClick }) {
  const [clickCount, setClickCount] = useState(0);

  function onRenderCallback(
    id, // 방금 커밋된 Profiler 트리의 "id"
    phase, // "mount" (트리가 방금 마운트가 된 경우) 혹은 "update"(트리가 리렌더링된 경우)
    actualDuration, // 커밋된 업데이트를 렌더링하는데 걸린 시간
    baseDuration, // 메모이제이션 없이 하위 트리 전체를 렌더링하는데 걸리는 예상시간
    startTime, // React가 언제 해당 업데이트를 렌더링하기 시작했는지
    commitTime, // React가 해당 업데이트를 언제 커밋했는지
    interactions // 이 업데이트에 해당하는 상호작용들의 집합
  ) {
    // 렌더링 타이밍을 집합하거나 로그...
    console.log(`actualDuration(${title}: ${actualDuration})`);
  }

  const handleClick = () => {
    onClick();
    setClickCount((prev) => prev + 1);
    alert(`${title} 눌림`);
  };

  const rate = useMemo(() => {
    console.log('rate check');
    return likes > 10 ? 'Good' : 'Bad';
  }, [likes]);

  return (
    <Profiler id='CommentItem' onRender={onRenderCallback}>
      <div className='CommentItem' onClick={handleClick}>
        <span>{title}</span>
        <br />
        <span>{content}</span>
        <br />
        <span>{likes}</span>
        <br />
        <span>{rate}</span>
        <br />
        <span>{clickCount}</span>
      </div>
    </Profiler>
  );
}

export default memo(CommentItem);
```

- 정리

  - Memoization
  - React.memo: HOC / Props 비교하여 메모
  - Profiler: 리액트 성능 분석 도구
  - callback: useCallback
  - vaiue: useMemo

#### 중간 복습

> Composition
> Composition: 컴포넌트에 컴포넌트 담기
> 담는 방법: Childeren, Custom
> typeof: type check
> 확장성: 다양한 상황을 품을 수 있도록

> HOC
> HOC: 함수를 받아서 함수를 리턴

> Memoization
> React.memo: HOC / Props 비교하여 메모
> Profiler: 리액트 성능 분석 도구
> callback: useCallback
> vaiue: useMemo

- 무언가를 만들려면?
- 스타일링이 막연하다면?
  - 다른 사이트를 카피해라 (습작, 따라 그리기, 반복연습)
  - 개발자도구로 스타일을 다 들여다 볼 수 있다.
  - 동작도 카피해봐라
  - 검색하면 다 나온다 (까짓것 하면 되지~ 라는 마인드가 중요!)